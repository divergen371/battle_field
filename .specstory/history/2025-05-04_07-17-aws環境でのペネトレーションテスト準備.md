<!-- Generated by SpecStory -->

# AWS環境でのペネトレーションテスト準備 (2025-05-04 16:17:54)

_**User**_

AWSでMetasploitableやOWASP Juice Shop、TerraGoat、iam-vulnerable、CloudGoat、AWSGoatなど意図的に脆弱性をもたせた環境を構築してペネトレーションテストの練習をしたい。Terraformを使い環境の管理を行えるようにする。環境構築に必要な観点の洗い出しと要件定義を行って。

---

_**Assistant**_

▼ 前提  
ペネトレーションテスト演習用に、以下の意図的に脆弱なスタックを AWS 上に展開し、Terraform で一元管理する。  
‐ Metasploitable 2/3  
‐ OWASP Juice Shop  
‐ TerraGoat (IaC 脆弱性演習)  
‐ iam-vulnerable  
‐ CloudGoat  
‐ AWSGoat  

これらは EC2・ECS/Fargate・各種マネージドサービスを組み合わせて構築されるため、環境を安全・廉価に運用するための設計観点と要件を整理する。

--------------------------------------------------------------------
■ １．設計観点（洗い出し）
--------------------------------------------------------------------
1. アカウント／組織設計  
   • 本番環境と完全に分離された「演習専用 AWS アカウント」を用意  
   • AWS Organizations 利用時は Service Control Policy で外部リージョン利用や課金上限をガード

2. ネットワーク／隔離  
   • VPC は演習用に専用作成（CIDR 競合回避）  
   • パブリック演習環境は踏み台（bastion）経由または VPN/Direct Connect 経由に限定  
   • 高リスクシナリオは Private Subnet ＋ NAT Gateway で外向きのみ許可

3. IAM・権限管理  
   • Terraform 用サービスアカウント（最小権限）と受講者ロールを分離  
   • iam-vulnerable 等の「脆弱ロール」は明示的にパス条件で閉じ込める  
   • アカウントルート鍵の無効化、MFA 必須

4. ログ・監査・検知  
   • CloudTrail & S3 バケット（暗号化）  
   • GuardDuty / Security Hub / AWS Config  
   • VPC Flow Logs・ELB/ALB アクセスログ  
   • 予算超過通知用 AWS Budgets & SNS

5. コスト管理 / 破棄自動化  
   • 全リソースに必ず `ttl` タグを付与し、Lambda または SSM Automation で自動削除  
   • Terraform destroy で確実にクリーンアップできるモジュラ設計  
   • スポット／Savings Plan 活用、無料枠踏み越えアラート

6. Terraform 運用  
   • S3 + DynamoDB Lock を back-end に使用  
   • workspace or tfvars により「シナリオ別」「受講者別」環境を切替え  
   • module をサービスごとに分離し再利用性を確保  
   • lint（tflint, tfsec）, CI/CD（GitHub Actions 等）組込み

7. セキュリティ対策と演習安全性  
   • Internet GW や SG の 0.0.0.0/0 は最小限、許可 IP 制限を可変入力  
   • DNS 名の外部公開有無をシナリオで選択  
   • 攻撃による踏み台化防止に AWS WAF / Rate-Limit をオプション提供

8. 監視・メトリクス  
   • CloudWatch Dashboard に主要リソースの CPU, NetworkOut, NAT DataProcessed 等を可視化  
   • 演習による高負荷・DoS を自動通知

9. バージョン管理／再現性  
   • 脆弱 AMI やコンテナイメージのハッシュ固定  
   • Tag ベースでいつでも同じ状態を再構築可能

10. ドキュメンテーション／ユーザビリティ  
    • README にシナリオ概要・学習目標・アクセス URL 手順を記載  
    • Terraform 変数例を examples/ 以下に格納

--------------------------------------------------------------------
■ ２．要件定義
--------------------------------------------------------------------
［機能要件］  
F-1  受講者は Terraform 変数を１ファイル指定するだけで任意のシナリオを deploy/ destroy できること  
F-2  Metasploitable は EC2、Juice Shop は ECS(Fargate) or Lambda(URL)、他は公式リポジトリに準拠  
F-3  各シナリオごとに異なる脆弱性 (OS, Web, IAM, S3 等) へアクセス可能  
F-4  受講者のグローバル IP（複数可）でのみ外部アクセスを許可  
F-5  シナリオ起動～利用開始が 15 分以内、破棄が 10 分以内

［非機能要件］  
N-1  全リソースに `Owner`, `Scenario`, `CreatedAt`, `ttl` タグを付与  
N-2  1 日あたりの予算 20 USD を超えた場合は自動停止 or SNS 通知  
N-3  モジュール単位で 90% 以上のコードが再利用可能  
N-4  Terraform ドリフトを nightly plan & 警告で検知

［セキュリティ要件］  
S-1  AWS アカウントは演習用で本番データを保持しない  
S-2  CloudTrail, GuardDuty, Config を常時有効  
S-3  作業ロールは session duration 4 時間、MFA 条件付き  
S-4  公開 URL には `*.training.example.com` の専用サブドメインのみ使用し、実ドメインと分離

［運用要件］  
O-1  GitHub Actions で `terraform fmt`, `tflint`, `tfsec` → plan → apply (要承認) のワークフロー  
O-2  毎週日曜 02:00 に未使用環境を自動 destroy  
O-3  シナリオ追加は README と variables.tf を更新するだけで可能

［パフォーマンス／スケーラビリティ要件］  
P-1  Juice Shop へ同時 50 リクエストを裁ける（t3.micro Fargate で概ね可）  
P-2  高負荷時に手動でタスク数を上げられる設定を残す

［可観測性要件］  
M-1  演習時間中の CloudWatch Logs を保持 14 日、S3 転送で 90 日保管  
M-2  主要メトリクスを Slack / Teams へ通知

--------------------------------------------------------------------
■ ３．次のステップ
--------------------------------------------------------------------
1. Terraform リポジトリ初期化  
   • `/modules` にシナリオ別モジュール、`/environments` に受講者/日別ワークスペースを配置  
2. ベースインフラ (VPC, IGW/NAT, Bastion, CW Logs, S3 backend) モジュール作成  
3. 各脆弱環境モジュールの実装  
   • Metasploitable: community AMI 参照、userdata で sshd/ftp 開放  
   • Juice Shop: ECR へ push → ECS/Fargate の Service/Task 定義  
   • CloudGoat/AWSGoat/TerraGoat/iam-vulnerable: 公式テンプレートを sub-module 化  
4. CI/CD, lint, tfsec 連携  
5. README と変数サンプル作成、テストデプロイ  
6. コスト＆削除 Lambda の実装 → 本番（演習）開始  

上記を満たすことで、安全・効率的に AWS 上で脆弱環境を構築し、Terraform で再現性を担保しながらペネトレーションテスト演習を行える。

---

_**User**_

この要件に沿って構築した環境のコストの試算を行って

---

_**Assistant**_

以下は 「us-east-1（バージニア北部）」「オンデマンド課金」「1 か月＝730 時間」 を前提にした概算です。実際の使用量・リージョン・Savings Plans 等で変動しますので、あくまで目安としてご覧ください。円滑な演習のために「共通基盤（常時起動）」と「シナリオ別（任意の演習時間だけ起動）」を分けて試算しています。  

────────────────────────────────────
1. 共通基盤コスト（常時稼働）
────────────────────────────────────
| リソース                                           | 単価(USD)          | 月間コスト(USD) | 備考 |
|---------------------------------------------------|--------------------|-----------------|------|
| NAT Gateway 1 台                                  | $0.045/時          |   32.9          | データ処理量は無視 (小規模想定)|
| Bastion EC2 (t3.micro, 8 GiB gp3)                 | $0.0104/時 + $0.08/GB月 | 7.6 + 0.6 ≒ 8.2 | 20 GB ルート EBS |
| S3 ログバケット 100 GB (標準)                     | $0.023/GB月        |    2.3          | CloudTrail, Flow Logs 14〜90 日保管|
| CloudTrail (約 20 M イベント/月)                  | $0.05/100k         |    10           | 標準ログストレージは上段 S3 に集約|
| GuardDuty (アカウント 1/リージョン)               | 変動（$1/GB / 100万Evt）|    11           | “中小規模”稼働時の平均値|
| AWS Config (5 k ConfigItem/日)                    | $0.003/Item        |    11           | |
| ALB/NLB なし (※Juice Shop 専用で後述)             | —                  |     —           | |
| CloudWatch Dash & Logs 保持（5 GB/月）            | $0.50/GB + メトリクス|     3           | |
| 予算アラート / SNS                                | $0.10/1k 通知      |  <1             | |
| 合計                                             |                    | ≒ 78 USD/月     | 日額 ≒ 2.6 USD |

────────────────────────────────────
2. シナリオ別の増分コスト
────────────────────────────────────
                               （単位：USD、24 h × 30 日フル稼働時）
| シナリオ                     | 主要リソース/構成                                    | 時間単価 | 月額 | 8h ラボ(1日) |
|------------------------------|-----------------------------------------------------|----------|------|-------------|
| Metasploitable2 (t3.small)   | EC2 t3.small + 25 GB gp3                            | $0.0208 + 0.0027 | 15.7 + 1.9 ≒ 17.6 | 0.67 |
| OWASP Juice Shop             | Fargate 1vCPU/2GB + ALB + 1 GB ECR                 | $0.0494 + 0.027  | 36.0 + 19.7 ≒ 55.7 | 2.32 |
| TerraGoat                    | S3×2(1 GB), Lambda 3×, API GW, DynamoDB small       | —        |  ≈ 5 | 0.17 |
| iam-vulnerable               | IAM リソースのみ（課金なし）                         | 0        |  0   | 0 |
| CloudGoat  ※演習単発         | t3.micro EC2、RDS micro (停止可)、S3 1 GB etc.      | —        |  ≈ 8 | 0.27 |
| AWSGoat   ※演習単発         | EC2×2(t3.micro)、ALB、S3 5 GB、SNS 等               | —        |  ≈ 12 | 0.40 |

※「8h ラボ」は 1 日 8 時間だけ起動した場合のコスト (共通基盤含まず)。  

────────────────────────────────────
3. 想定シナリオ組合せ別コスト例
────────────────────────────────────
A. フル常時稼働（全部入り）  
　78 $（基盤）＋17.6＋55.7＋5＋0＋8＋12 ＝ 約 176 USD/月  

B. 週末ハンズオン（1 日 8h、全部入り）  
　基盤 2.6 $／日 ×30＝78　＋シナリオ合計(0.67+2.32+0.17+0+0.27+0.40)=3.83 ×4日(毎週末) ≒ 15.3  
　→ 月総額 ≒ 93 USD  

C. Metasploitable と Juice Shop だけ常時  
　78 + 17.6 + 55.7 ≒ 151 USD/月  

────────────────────────────────────
4. コスト最適化ポイント
────────────────────────────────────
1. NAT Gateway をやめて “1 台踏み台＋踏み台の NAT (squid)” に変更 → 月額 -30 $  
2. Bastion／JuiceShop を t3a 系 or Spot へ切替 → EC2 部分 -10〜15 %  
3. Fargate は “起動時のみ” に自動スケールイン（最小 0 Task） → Juice Shop idle 時 0 $  
4. ALB は演習時のみ作成し、CLI スクリプトで即破棄 → -19.7 $/月  
5. GuardDuty, Config をリージョン絞り / 無効化タイミング制御 → -5〜10 $  
6. TTL タグ＋Lambda で未使用リソース自動 destroy（本試算の 8h ラボ相当を実装）  

────────────────────────────────────
5. まとめ
────────────────────────────────────
・「基盤のみ」で ≈ 78 USD/月。  
・メジャーシナリオを 24 h 常時にすると 150〜176 USD/月。  
・TTL により「演習時間のみ起動 (8 h)」運用へ寄せれば 90〜100 USD/月以内に抑制可能。  
・演習アカウントに AWS Budget (20 USD/日) を設定し、越えたら自動 `terraform destroy` or SNS 通知とすることでコスト逸脱リスクを最小化。  

この試算をベースに、実際のアクセス負荷・データ量を確認しながら Savings Plans/Spot 適用やリソースサイズの調整を行うとよいでしょう。

---

_**User**_

個人で行う学習の環境としてコスト最適化しよう。

---

_**Assistant**_

▼ 目的  
個人学習用として「なるべく無料枠と従量課金の最小限利用」で脆弱環境を立て、演習が終わったら完全に消す運用へフォーカスします。月数回・数時間だけ触る想定で、月額 10〜30 USD 程度に抑えることを目標にします。

────────────────────────────────────
1. 設計ポリシー（最安化のための原則）
────────────────────────────────────
1) “常時稼働リソース” をゼロにする  
　• NAT Gateway・踏み台 EC2 を置かず、無料の AWS CloudShell／Session Manager／SSM PortForward を併用。  
　• CloudTrail 等の監査系も必要最低限に絞り、リージョンを 1 か所に固定。  

2) 「演習開始 → apply」「演習終了 → destroy」を徹底  
　• wrapper スクリプト `./run.sh start metasploitable` → `./run.sh stop metasploitable` で自動実行。  
　• Terraform backend は `local` にして State はローカル暗号化。  

3) 料金の高いマネージドコンポーネントを回避／置換  
　• ALB → API Gateway HTTP API (従量課金・低価格) または直接パブリック IP。  
　• Fargate → Spot Fargate（通常の 70% 引き）または Docker on EC2。  
　• RDS→ SQLite / Docker 内部 DB に置換（CloudGoat の一部シナリオのみ例外）。  

4) 無料枠／Graviton t4g.micro を使い倒す  
　• t4g.micro は 750 時間/月無償（12 か月）＋ Spot も最安。  
　• ARM 未対応 AMI は QEMU 変換せず、短時間なら t3.micro の Spot へ。  

5) 有料サービスの停止忘れ防止  
　• EventBridge Rule + Lambda で「午前 2 時に強制 `terraform destroy`」。  
　• AWS Budgets アラートを 10 USD/月・1 USD/日 に設定。  

────────────────────────────────────
2. シナリオ別の最小構成とコスト（2 時間演習）
────────────────────────────────────
| シナリオ            | 構成 (低コスト版)                        | 時間単価 | 2h 演習 | 備考 |
|---------------------|-------------------------------------------|----------|---------|------|
| Metasploitable2     | t4g.micro Spot (≒$0.0012/h) + 10 GB gp3 | 0.0012   | 0.0024  | EBS はスナップショット保存・再利用 |
| OWASP Juice Shop    | Fargate Spot 0.5vCPU/1GB + API GW        | 0.007    | 0.014   | ALB 不要、API GW 1 万リクエスト≒$1 |
| TerraGoat           | S3(数 MB), Lambda/ApiGW 少数              | ほぼ 0   | 0       | 無料枠内 |
| iam-vulnerable      | IAM リソースのみ                          | 0        | 0       | |
| CloudGoat           | 必要最小限のシナリオだけ選択（EC2/RDS）   | 0.02*    | 0.04*   | *t3.micro Spot & RDS Stopped 時間課金 |
| AWSGoat             | EC2×1 t4g.micro Spot、S3 少量             | 0.0012   | 0.0024 | |

2 時間フルで全部触っても合計 ≒ 0.06 USD  
（月 4 回演習しても 0.24 USD＋スナップショット数十円程度）

────────────────────────────────────
3. Terraform プラクティス
────────────────────────────────────
• `terraform.tfvars` に `ttl_hours = 2` を設定し、`null_resource` + `local-exec` で `sleep ${ttl_hours}h && terraform destroy -auto-approve` を自動実行。  
• `make start SCENARIO=juice_shop` で対象モジュールだけ `apply`。  
• `cloudshell` で作業すればローカル PC 側に AWS 認証情報を持たずに済む。  

────────────────────────────────────
4. コスト削減アイテム一覧
────────────────────────────────────
- NAT Gateway  → 0（すべてパブリックサブネット＋SG 制限）  
- Bastion EC2  → 0（CloudShell/SSM）  
- GuardDuty    → 無効  
- Config       → 無効, drift は `terraform plan` で代替  
- CloudTrail   → マネジメントプレーンのみ 1 リージョン  
- Logs/S3      → S3 Intelligent-Tiering + 30 日自動削除  
- CloudWatch   → 演習時のみエージェント有効  
- ALB          → API GW かインスタンス直叩き  
- RDS          → 起動後すぐ `stop`、演習時は `start-db-instance`  
- EBS          → `DeleteOnTermination=false` + snapshot 圧縮  

────────────────────────────────────
5. 想定月額シミュレーション
────────────────────────────────────
前提：月 4 回、各 2 時間、全シナリオ実行、スナップショット計 40 GB

• 計算
　− 実行リソース：0.06 USD × 4 = 0.24 USD  
　− スナップショット：0.05 USD/GB月 × 40 = 2.0 USD  
　− CloudTrail/S3/Logs：1 USD 程度  
　→ 月額 合計 ≒ 3.3 USD  

これなら 5 USD 以内に収まります。  

────────────────────────────────────
6. まとめ & 実装タスク
────────────────────────────────────
1. Terraform モジュールを「シナリオ単位」で完全分離し、依存ゼロ化。  
2. `ttl_hours` 変数と自動 destroy ラムダ／null_resource で “消し忘れゼロ”。  
3. IAM, NAT, GuardDuty 等の有料常時サービスはオフ。  
4. AWS Budgets の日次 1 USD 超警告を Slack/Webhook へ。  
5. wrapper スクリプト (`run.sh`) を作成し  
   ```
   ./run.sh start juice_shop
   ./run.sh stop juice_shop
   ```  
   で apply/destroy＋後片付けを実現。  

上記を守れば、個人学習でも月数ドルで安全・低コストに脆弱環境を構築できます。

---

_**User**_

その方針で要件をまとめて

---

_**Assistant**_

▼ 個人学習向け・超低コスト脆弱環境（AWS＋Terraform）要件一覧  
（月額 5 USD 以内・“使う時だけ起動／終わったら完全破棄” 方針）

────────────────────────────────────
1. 機能要件
────────────────────────────────────
F-1　Terraform コマンド 2 つだけで各シナリオを開始／終了できる  
　　　例）`make start SCENARIO=juice_shop`、`make stop SCENARIO=juice_shop`  
F-2　対応シナリオ：Metasploitable2、OWASP Juice Shop、TerraGoat、iam-vulnerable、CloudGoat(最小のみ)、AWSGoat(最小のみ)  
F-3　演習 1 回あたり 2 時間以内で完結し、終了後は AWS 内に課金対象リソースが残らない  
F-4　利用者の固定グローバル IP（または自宅 CIDR）のみ Security Group で許可  
F-5　デプロイ完了まで 10 分以内、destroy は 5 分以内  

────────────────────────────────────
2. 非機能要件（コスト最適化特化）
────────────────────────────────────
N-1　“常時稼働” リソースをゼロにする  
　　・NAT Gateway／踏み台 EC2／GuardDuty／Config／ALB は原則作らない  
N-2　演習インスタンスは Spot（または無料枠 t4g.micro）を利用  
N-3　EBS は `DeleteOnTermination=false`＋スナップショット圧縮で長期保存  
N-4　Terraform backend は `local`、State はローカル暗号化（S3 不使用）  
N-5　`ttl_hours` 変数で自動破棄を保証し、削除忘れを 0 件にする  

────────────────────────────────────
3. セキュリティ要件
────────────────────────────────────
S-1　演習用 IAM ユーザー／ロールは最小権限（自アカウント外リソース不可）  
S-2　接続は AWS CloudShell か SSM Session Manager を使用し、SSH 鍵は公開しない  
S-3　CloudTrail はマネジメントプレーン（1 リージョン）のみ有効  
S-4　Budget アラートを「1 USD／日」「10 USD／月」で SNS 通知  

────────────────────────────────────
4. 運用要件
────────────────────────────────────
O-1　Makefile または bash スクリプト `run.sh` で  
　　　start → `terraform init/plan/apply` ＆ destroy 予約  
O-2　EventBridge ルール（毎日 02:00）で強制 `terraform destroy` 実行  
O-3　GitHub など外部 CI は使わず、ローカル PC or CloudShell 上で直接実行  
O-4　追加シナリオは `/modules/<scenario>` フォルダを作り変数例を置くだけで拡張  

────────────────────────────────────
5. 可観測性・ログ要件
────────────────────────────────────
M-1　CloudWatch エージェントは演習開始時に ON、destroy 時に OFF  
M-2　ログは S3 Intelligent-Tiering に転送し 30 日でライフサイクル削除  
M-3　ログ保管サイズが 1 GB/月 を超えないこと  

────────────────────────────────────
6. コスト要件
────────────────────────────────────
C-1　「演習実行コスト」：全シナリオを同時起動しても 0.06 USD／2h 以内  
C-2　「月額固定コスト」：スナップショット＋ログ＋CloudTrail 合計 5 USD 未満  
C-3　Budgets 超過時は自動 destroy または SNS 通知後に手動対応  

────────────────────────────────────
7. 技術スタック／構成詳細
────────────────────────────────────
• Metasploitable2　　→ Spot t4g.micro, パブリック IP, SG 制限のみ  
• Juice Shop　　　　→ Fargate Spot 0.5vCPU/1GB + API Gateway HTTP API  
• TerraGoat　　　　 → S3, Lambda, DynamoDB（全て無料枠）  
• iam-vulnerable　　 → IAM, Policy のみ（料金ゼロ）  
• CloudGoat / AWSGoat→ 必要な EC2/RDS を最小構成で Spot & RDS 停止モード  
• すべての VPC はパブリックサブネットのみ、IGW 経由で直接通信  
• IaC lint 等の CI 工程はローカル実行（tflint / tfsec）  

────────────────────────────────────
8. 実装タスク
────────────────────────────────────
1) Terraform リポジトリ初期化（backend local）  
2) `/modules` にシナリオ別モジュールを作成（依存ゼロ設計）  
3) 共通変数 `ttl_hours`, `my_ip_cidr` を定義  
4) `run.sh`（または Makefile）で start/stop ラッパー実装  
5) EventBridge + Lambda で “日次強制 destroy” をデプロイ  
6) AWS Budgets & SNS 通知設定  
7) 動作検証 → README に手順・料金目安を明記  

これらの要件を満たせば、個人学習でも安全かつ月 5 USD 以内で複数の脆弱シナリオを自由に構築・破棄できる Terraform ベースの環境が実現できます。

---

_**User**_

では、実際の作業に進む前に要件からタスクを抽出しましょう

---

_**Assistant**_

▼ 要件をもとにした実装タスク一覧  
  
括弧内は依存関係 →「A → B」は A 完了後に B 着手。優先度は ★3 高 ～ ★1 低。

────────────────────────────────────  
1. リポジトリ初期化 & 基本構成  
────────────────────────────────────  
★3 1-1. Git リポジトリ初期化・ディレクトリ作成  
　　　`/modules /scripts /examples /doc` を用意  
★3 1-2. `backend "local"` を記述した共通 `main.tf` 雛形作成  
★3 1-3. 入力変数ファイル `variables.tf` に以下を定義  
　　　`ttl_hours`, `my_ip_cidr`, `scenario_name`  
★2 1-4. Makefile or `scripts/run.sh` の枠だけ作成（start/stop サブルール）

────────────────────────────────────  
2. 共通ライブラリ／ユーティリティ  
────────────────────────────────────  
★3 2-1. TTL 自動破棄ロジック  
　　　a. null_resource + local-exec（sleep → destroy）  
　　　b. EventBridge → Lambda 00:00 実行（どちらか実装）  
★2 2-2. SG テンプレート（許可 CIDR だけ変数）  
★2 2-3. CloudTrail（マネジメントプレーンのみ）モジュール  
★1 2-4. CloudWatch Agent ON/OFF toggle Script（EC2 用）  

────────────────────────────────────  
3. シナリオ別モジュール作成  
────────────────────────────────────  
★3 3-1. metasploitable2 モジュール  
　　　– Spot t4g.micro／パブリックIP／ユーザーデータで弱点サービス ON  
★3 3-2. juice_shop モジュール  
　　　– Fargate Spot Task 0.5vCPU/1GB + HTTP API GW  
★2 3-3. terra_goat モジュール（公式テンプレ簡易流用）  
★2 3-4. iam_vulnerable モジュール（IAM JSON 模型のみ）  
★2 3-5. cloudgoat_min モジュール（EC2 + RDS stopped）  
★2 3-6. awsgoat_min モジュール（EC2 + S3 最小）  

────────────────────────────────────  
4. スクリプト & UX  
────────────────────────────────────  
★3 4-1. `scripts/run.sh` 実装  
　　　start: `terraform init → plan → apply`  
　　　stop : `terraform destroy`（IDempotent 処理）  
★2 4-2. `scripts/check_cost.sh`（AWS CLI で当日使用額を取得）  
★1 4-3. `scripts/lint.sh`：`terraform fmt -check` / `tflint` / `tfsec`

────────────────────────────────────  
5. コスト・セキュリティガード  
────────────────────────────────────  
★3 5-1. AWS Budgets 10 USD/月, 1 USD/日 作成スクリプト  
★2 5-2. SNS Topic + Email/Slack Webhook 通知  
★1 5-3. IAM ロール: 演習用最小ポリシーの CloudFormation or Terraform

────────────────────────────────────  
6. ドキュメント & サンプル  
────────────────────────────────────  
★2 6-1. `README.md`：前提・使い方・注意点・料金例  
★2 6-2. `examples/` に `metasploitable.auto.tfvars.example` 等を配置  
★1 6-3. ラボの手順書（doc/labs/）とコスト試算表追記

────────────────────────────────────  
7. 動作検証 & リリース  
────────────────────────────────────  
★3 7-1. 全シナリオで `make start → 2h → auto-destroy` テスト  
★2 7-2. 破棄後に課金対象リソースが残らないことを AWS CLI で確認  
★2 7-3. リポジトリ初版タグ付け・公開  

これらのタスクを順に実施すれば、要件で定義した「超低コスト・個人学習用脆弱環境」を Terraform で構築・運用できます。

---

_**User**_

1.リポジトリ初期化＆基本構成から始めましょう

---

_**Assistant**_



---

まず、リポジトリ初期化と基本的なディレクトリ構造を作成しましょう。以下のコマンドを順番に実行します：

---

```bash
mkdir -p modules scripts examples doc
```

```
❯ mkdir -p modules scripts examples doc



❯ 

~/battle_field                                                             16:45:19
❯
```

---

次に、Gitリポジトリを初期化します：

---

Cancelled

---

_**User**_

こちらで「git init」を実行しました

---

_**Assistant**_



---

次に、Terraformのローカルバックエンドを設定した基本的な`main.tf`を作成しましょう：

---

```diff
- 
+ terraform {
+   required_version = ">= 1.0.0"
+   required_providers {
+     aws = {
+       source  = "hashicorp/aws"
+       version = "~> 5.0"
+     }
+   }
+   # ローカルバックエンド設定（コスト最適化のためS3は使用しない）
+   backend "local" {
+     path = "terraform.tfstate"
+   }
+ }
+ 
+ provider "aws" {
+   region = var.aws_region
+   default_tags {
+     tags = {
+       Environment = "pentest-lab"
+       Terraform   = "true"
+       TTL         = "${var.ttl_hours}h"
+       Owner       = "security-training"
+     }
+   }
+ } 
```

---

次に、`variables.tf`ファイルを作成して必要な変数を定義します：

---

```diff
- 
+ variable "aws_region" {
+   description = "AWS実行リージョン"
+   type        = string
+   default     = "ap-northeast-1"
+ }
+ 
+ variable "ttl_hours" {
+   description = "リソースの生存期間（時間）。この時間後に自動破棄されます"
+   type        = number
+   default     = 2
+ }
+ 
+ variable "my_ip_cidr" {
+   description = "アクセスを許可するIPアドレス（CIDR形式）"
+   type        = string
+   # デフォルト値は実際の使用時に上書きする
+   default     = "0.0.0.0/0"
+   validation {
+     condition     = can(cidrnetmask(var.my_ip_cidr))
+     error_message = "my_ip_cidrは有効なCIDR形式（例：1.2.3.4/32）で指定してください"
+   }
+ }
+ 
+ variable "scenario_name" {
+   description = "実行するシナリオ名"
+   type        = string
+   default     = "all"
+   validation {
+     condition     = contains(["all", "metasploitable2", "juice_shop", "terra_goat", "iam_vulnerable", "cloudgoat_min", "awsgoat_min"], var.scenario_name)
+     error_message = "シナリオ名は定義済みのものから選択してください"
+   }
+ }
+ 
+ variable "project_name" {
+   description = "プロジェクト名（リソース名のプレフィックス）"
+   type        = string
+   default     = "pentest-lab"
+ } 
```

---

続いて、`run.sh`スクリプトの基本枠組みを作成します：

---

```diff
- 
+ #!/bin/bash
+ 
+ # エラー発生時に停止
+ set -e
+ 
+ # 色の定義
+ RED='\033[0;31m'
+ GREEN='\033[0;32m'
+ YELLOW='\033[0;33m'
+ NC='\033[0m' # No Color
+ 
+ # 使用方法表示
+ function usage {
+   echo -e "${YELLOW}Usage:${NC}"
+   echo -e "  $0 start <scenario_name> [--ip <your_ip>/32] [--ttl <hours>]"
+   echo -e "  $0 stop <scenario_name>"
+   echo -e ""
+   echo -e "${YELLOW}Available scenarios:${NC}"
+   echo -e "  metasploitable2, juice_shop, terra_goat, iam_vulnerable, cloudgoat_min, awsgoat_min, all"
+   echo -e ""
+   echo -e "${YELLOW}Examples:${NC}"
+   echo -e "  $0 start juice_shop --ip 203.0.113.10/32 --ttl 3"
+   echo -e "  $0 stop juice_shop"
+   exit 1
+ }
+ 
+ # 引数チェック
+ if [ $# -lt 2 ]; then
+   usage
+ fi
+ 
+ ACTION=$1
+ SCENARIO=$2
+ IP_CIDR=""
+ TTL=2
+ 
+ # オプション引数の処理
+ shift 2
+ while [[ "$#" -gt 0 ]]; do
+   case $1 in
+     --ip)
+       IP_CIDR="$2"
+       shift 2
+       ;;
+     --ttl)
+       TTL="$2"
+       shift 2
+       ;;
+     *)
+       echo -e "${RED}Unknown parameter: $1${NC}"
+       usage
+       ;;
+   esac
+ done
+ 
+ # ディレクトリ設定
+ SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
+ ROOT_DIR="$(dirname "$SCRIPT_DIR")"
+ cd $ROOT_DIR
+ 
+ # チェック：シナリオの存在確認
+ valid_scenarios=("metasploitable2" "juice_shop" "terra_goat" "iam_vulnerable" "cloudgoat_min" "awsgoat_min" "all")
+ if [[ ! " ${valid_scenarios[@]} " =~ " ${SCENARIO} " ]]; then
+   echo -e "${RED}Error: Invalid scenario '${SCENARIO}'${NC}"
+   usage
+ fi
+ 
+ # 行動判定
+ case $ACTION in
+   start)
+     # IPアドレスの指定がなければ取得を試みる
+     if [ -z "$IP_CIDR" ]; then
+       echo -e "${YELLOW}注意: IPアドレスが指定されていません。自動検出を試みます...${NC}"
+       MY_IP=$(curl -s https://checkip.amazonaws.com)
+       if [ -n "$MY_IP" ]; then
+         IP_CIDR="${MY_IP}/32"
+         echo -e "${GREEN}現在のグローバルIPを使用します: ${IP_CIDR}${NC}"
+       else
+         echo -e "${RED}IPアドレスの自動検出に失敗しました。--ip オプションで明示的に指定してください。${NC}"
+         exit 1
+       fi
+     fi
+     
+     # Terraformの実行
+     echo -e "${GREEN}シナリオ '${SCENARIO}' を開始（TTL: ${TTL}時間）${NC}"
+     terraform init
+     terraform plan -var="ttl_hours=${TTL}" -var="my_ip_cidr=${IP_CIDR}" -var="scenario_name=${SCENARIO}"
+     terraform apply -auto-approve -var="ttl_hours=${TTL}" -var="my_ip_cidr=${IP_CIDR}" -var="scenario_name=${SCENARIO}"
+     
+     echo -e "${GREEN}環境が起動しました。${TTL}時間後に自動的に破棄されます${NC}"
+     echo -e "${YELLOW}早く終了したい場合は 'run.sh stop ${SCENARIO}' を実行してください${NC}"
+     ;;
+     
+   stop)
+     echo -e "${YELLOW}シナリオ '${SCENARIO}' を停止します...${NC}"
+     terraform destroy -auto-approve -var="scenario_name=${SCENARIO}"
+     echo -e "${GREEN}環境が正常に破棄されました${NC}"
+     ;;
+     
+   *)
+     echo -e "${RED}不明なアクション: ${ACTION}${NC}"
+     usage
+     ;;
+ esac 
```

---

スクリプトに実行権限を付与します：

---

```bash
chmod +x scripts/run.sh
```

---

_**User**_

スクリプトへの実行権限付与はこちらで行った

---

_**Assistant**_



---

次に、TTL自動破棄ロジックを実装します。これはリソースが指定時間後に自動的に破棄されるようにするための重要な機能です。

まず、共通モジュールディレクトリを作成しましょう：

---

```bash
mkdir -p modules/common
```

---

_**User**_

共通モジュールディレクトリはこちらで作成した

---

_**Assistant**_



---

次に、TTL自動破棄ロジックを実装します。これはリソースが指定時間後に自動的に破棄されるためのモジュールです。

---

```diff
- 
+ variable "ttl_hours" {
+   description = "リソースの生存期間（時間）"
+   type        = number
+   default     = 2
+ }
+ 
+ variable "enabled" {
+   description = "TTL破棄機能を有効にするか"
+   type        = bool
+   default     = true
+ }
+ 
+ variable "scenario_name" {
+   description = "破棄対象のシナリオ名"
+   type        = string
+ }
+ 
+ resource "null_resource" "ttl_destroyer" {
+   count = var.enabled ? 1 : 0
+ 
+   # TTL時間が変更されたら再実行
+   triggers = {
+     ttl_hours = var.ttl_hours
+   }
+ 
+   # terraform destroyをバックグラウンドで予約実行
+   provisioner "local-exec" {
+     command = <<-EOT
+       (
+         # バックグラウンドで実行
+         echo "TTL: ${var.ttl_hours}時間後（$(date -d "+${var.ttl_hours} hour" "+%Y-%m-%d %H:%M:%S")）に'${var.scenario_name}'シナリオを自動破棄します"
+         sleep ${var.ttl_hours * 3600}
+         cd ${path.root}
+         echo "TTL期限切れ: '${var.scenario_name}'シナリオを自動破棄します（$(date "+%Y-%m-%d %H:%M:%S")）"
+         terraform destroy -auto-approve -var="scenario_name=${var.scenario_name}"
+       ) &>/tmp/ttl_destroyer_${var.scenario_name}.log &
+     EOT
+   }
+ }
+ 
+ output "destruction_time" {
+   description = "リソース自動破棄予定時刻"
+   value       = var.enabled ? formatdate("YYYY-MM-DD HH:mm:ss", timeadd(timestamp(), "${var.ttl_hours}h")) : "無効"
+ } 
```

---

次に、セキュリティグループのテンプレートを作成します。これは各シナリオで再利用できるようにします：

---

```diff
- 
+ variable "vpc_id" {
+   description = "セキュリティグループを作成するVPC ID"
+   type        = string
+ }
+ 
+ variable "allowed_cidr" {
+   description = "接続を許可するCIDR"
+   type        = string
+   default     = "0.0.0.0/0"
+ }
+ 
+ variable "name_prefix" {
+   description = "セキュリティグループ名のプレフィックス"
+   type        = string
+ }
+ 
+ variable "description" {
+   description = "セキュリティグループの説明"
+   type        = string
+   default     = "脆弱環境アクセス用セキュリティグループ"
+ }
+ 
+ # 基本的なInbound/Outboundルールを持つセキュリティグループ
+ resource "aws_security_group" "this" {
+   name        = "${var.name_prefix}-sg"
+   description = var.description
+   vpc_id      = var.vpc_id
+ 
+   # 許可されたCIDRからの接続のみ許可
+   ingress {
+     from_port   = 22
+     to_port     = 22
+     protocol    = "tcp"
+     cidr_blocks = [var.allowed_cidr]
+     description = "許可されたCIDRからのSSH接続"
+   }
+ 
+   ingress {
+     from_port   = 80
+     to_port     = 80
+     protocol    = "tcp"
+     cidr_blocks = [var.allowed_cidr]
+     description = "許可されたCIDRからのHTTP接続"
+   }
+ 
+   ingress {
+     from_port   = 443
+     to_port     = 443
+     protocol    = "tcp"
+     cidr_blocks = [var.allowed_cidr]
+     description = "許可されたCIDRからのHTTPS接続"
+   }
+ 
+   ingress {
+     from_port   = 3000
+     to_port     = 3000
+     protocol    = "tcp"
+     cidr_blocks = [var.allowed_cidr]
+     description = "許可されたCIDRからのJuice Shop接続"
+   }
+ 
+   ingress {
+     from_port   = 8080
+     to_port     = 8080
+     protocol    = "tcp"
+     cidr_blocks = [var.allowed_cidr]
+     description = "許可されたCIDRからのアプリケーション接続"
+   }
+ 
+   # 全ての外向き通信を許可
+   egress {
+     from_port   = 0
+     to_port     = 0
+     protocol    = "-1"
+     cidr_blocks = ["0.0.0.0/0"]
+     description = "全ての外向き通信"
+   }
+ 
+   tags = {
+     Name = "${var.name_prefix}-sg"
+   }
+ }
+ 
+ output "security_group_id" {
+   description = "作成されたセキュリティグループのID"
+   value       = aws_security_group.this.id
+ } 
```

---

次に、基本的なVPCモジュールを作成します：

---

```diff
- 
+ variable "vpc_cidr" {
+   description = "VPCのCIDRブロック"
+   type        = string
+   default     = "10.0.0.0/16"
+ }
+ 
+ variable "public_subnet_cidrs" {
+   description = "パブリックサブネットのCIDRブロックリスト"
+   type        = list(string)
+   default     = ["10.0.1.0/24", "10.0.2.0/24"]
+ }
+ 
+ variable "vpc_name" {
+   description = "VPC名"
+   type        = string
+ }
+ 
+ data "aws_availability_zones" "available" {
+   state = "available"
+ }
+ 
+ # コスト最適化のためシンプルなVPC（NAT Gateway無し、パブリックサブネットのみ）
+ resource "aws_vpc" "this" {
+   cidr_block           = var.vpc_cidr
+   enable_dns_hostnames = true
+ 
+   tags = {
+     Name = var.vpc_name
+   }
+ }
+ 
+ # Internet Gateway
+ resource "aws_internet_gateway" "this" {
+   vpc_id = aws_vpc.this.id
+ 
+   tags = {
+     Name = "${var.vpc_name}-igw"
+   }
+ }
+ 
+ # パブリックサブネット
+ resource "aws_subnet" "public" {
+   count = length(var.public_subnet_cidrs)
+ 
+   vpc_id                  = aws_vpc.this.id
+   cidr_block              = var.public_subnet_cidrs[count.index]
+   availability_zone       = data.aws_availability_zones.available.names[count.index % length(data.aws_availability_zones.available.names)]
+   map_public_ip_on_launch = true
+ 
+   tags = {
+     Name = "${var.vpc_name}-public-${count.index + 1}"
+   }
+ }
+ 
+ # パブリックルートテーブル
+ resource "aws_route_table" "public" {
+   vpc_id = aws_vpc.this.id
+ 
+   route {
+     cidr_block = "0.0.0.0/0"
+     gateway_id = aws_internet_gateway.this.id
+   }
+ 
+   tags = {
+     Name = "${var.vpc_name}-public-rt"
+   }
+ }
+ 
+ # パブリックサブネットとルートテーブルの関連付け
+ resource "aws_route_table_association" "public" {
+   count = length(aws_subnet.public)
+ 
+   subnet_id      = aws_subnet.public[count.index].id
+   route_table_id = aws_route_table.public.id
+ }
+ 
+ output "vpc_id" {
+   description = "作成されたVPC ID"
+   value       = aws_vpc.this.id
+ }
+ 
+ output "public_subnet_ids" {
+   description = "作成されたパブリックサブネットIDのリスト"
+   value       = aws_subnet.public[*].id
+ } 
```

---

次に、最優先度の高いMetasploitable2のモジュールを作成します：

---

```diff
- 
+ variable "project_name" {
+   description = "プロジェクト名（リソース名のプレフィックス）"
+   type        = string
+   default     = "pentest-lab"
+ }
+ 
+ variable "my_ip_cidr" {
+   description = "アクセスを許可するIPアドレス（CIDR形式）"
+   type        = string
+ }
+ 
+ variable "ttl_hours" {
+   description = "リソースの生存期間（時間）"
+   type        = number
+   default     = 2
+ }
+ 
+ # リソース名
+ locals {
+   name_prefix = "${var.project_name}-metasploitable2"
+ }
+ 
+ # VPCの作成
+ module "vpc" {
+   source = "../common"
+ 
+   vpc_name = "${local.name_prefix}-vpc"
+   vpc_cidr = "10.50.0.0/16"
+   public_subnet_cidrs = ["10.50.1.0/24"]
+ }
+ 
+ # セキュリティグループの作成
+ module "security_group" {
+   source = "../common"
+ 
+   vpc_id       = module.vpc.vpc_id
+   allowed_cidr = var.my_ip_cidr
+   name_prefix  = local.name_prefix
+   description  = "Metasploitable2用セキュリティグループ"
+ }
+ 
+ # 脆弱なサービスのために追加のポートを開放
+ resource "aws_security_group_rule" "metasploitable_additional_ports" {
+   for_each = {
+     ftp       = 21
+     telnet    = 23
+     smb       = 445
+     mysql     = 3306
+     postgres  = 5432
+     vnc       = 5900
+     java_rmi  = 1099
+     distcc    = 3632
+     tomcat    = 8180
+   }
+ 
+   security_group_id = module.security_group.security_group_id
+   type              = "ingress"
+   from_port         = each.value
+   to_port           = each.value
+   protocol          = "tcp"
+   cidr_blocks       = [var.my_ip_cidr]
+   description       = "Metasploitable2 - ${each.key}"
+ }
+ 
+ # Metasploitable2のAMIデータソース（Ubuntu 16.04ベース）
+ data "aws_ami" "ubuntu" {
+   most_recent = true
+   owners      = ["099720109477"] # Canonical
+ 
+   filter {
+     name   = "name"
+     values = ["ubuntu/images/hvm-ssd/ubuntu-xenial-16.04-amd64-server-*"]
+   }
+ 
+   filter {
+     name   = "virtualization-type"
+     values = ["hvm"]
+   }
+ }
+ 
+ # EC2インスタンスの起動テンプレート
+ resource "aws_launch_template" "metasploitable2" {
+   name          = "${local.name_prefix}-template"
+   image_id      = data.aws_ami.ubuntu.id
+   instance_type = "t3.micro" # ARM対応のMetasploitableがないためt3.microを使用
+ 
+   vpc_security_group_ids = [module.security_group.security_group_id]
+ 
+   # スポットインスタンスを使用
+   instance_market_options {
+     market_type = "spot"
+     spot_options {
+       max_price = "0.004" # 通常価格の50%程度
+     }
+   }
+ 
+   # Metasploitable2をDockerで実行するユーザーデータ
+   user_data = base64encode(<<-EOF
+     #!/bin/bash
+     # システムの更新
+     apt-get update
+     apt-get install -y docker.io
+ 
+     # Dockerサービスの起動
+     systemctl start docker
+     systemctl enable docker
+ 
+     # Metasploitable2イメージの取得と実行
+     docker pull tleemcjr/metasploitable2
+     docker run -d --name metasploitable2 \
+       --restart always \
+       -p 21:21 -p 22:22 -p 23:23 -p 25:25 -p 53:53 \
+       -p 80:80 -p 111:111 -p 139:139 -p 445:445 \
+       -p 512:512 -p 1099:1099 -p 1524:1524 \
+       -p 2049:2049 -p 2121:2121 -p 3306:3306 \
+       -p 3632:3632 -p 5432:5432 -p 5900:5900 \
+       -p 6000:6000 -p 6667:6667 -p 8009:8009 \
+       -p 8180:8180 tleemcjr/metasploitable2
+       
+     # ステータスファイルの作成
+     echo "Metasploitable2 is running. Connect to any service at $(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)" > /home/ubuntu/status.txt
+   EOF
+   )
+ 
+   # EBSボリュームの設定
+   block_device_mappings {
+     device_name = "/dev/sda1"
+ 
+     ebs {
+       volume_size           = 10
+       volume_type           = "gp3"
+       delete_on_termination = true
+     }
+   }
+ 
+   tag_specifications {
+     resource_type = "instance"
+ 
+     tags = {
+       Name    = "${local.name_prefix}-instance"
+       TTL     = "${var.ttl_hours}h"
+       Scenario = "metasploitable2"
+     }
+   }
+ 
+   tag_specifications {
+     resource_type = "volume"
+ 
+     tags = {
+       Name    = "${local.name_prefix}-volume"
+       TTL     = "${var.ttl_hours}h"
+       Scenario = "metasploitable2"
+     }
+   }
+ }
+ 
+ # EC2インスタンスの作成
+ resource "aws_instance" "metasploitable2" {
+   launch_template {
+     id      = aws_launch_template.metasploitable2.id
+     version = "$Latest"
+   }
+ 
+   subnet_id = module.vpc.public_subnet_ids[0]
+ 
+   tags = {
+     Name    = "${local.name_prefix}-instance"
+     TTL     = "${var.ttl_hours}h"
+     Scenario = "metasploitable2"
+   }
+ }
+ 
+ # TTL自動破棄
+ module "ttl_destroyer" {
+   source = "../common"
+ 
+   ttl_hours     = var.ttl_hours
+   enabled       = true
+   scenario_name = "metasploitable2"
+ }
+ 
+ output "metasploitable2_public_ip" {
+   description = "Metasploitable2のパブリックIP"
+   value       = aws_instance.metasploitable2.public_ip
+ }
+ 
+ output "connection_instructions" {
+   description = "接続方法"
+   value       = <<-EOT
+     Metasploitable2の環境が起動しました！
+     
+     パブリックIP: ${aws_instance.metasploitable2.public_ip}
+     
+     以下のサービスにアクセスできます：
+     - SSH: ssh -p 22 ${aws_instance.metasploitable2.public_ip} (user: msfadmin, pass: msfadmin)
+     - FTP: ftp ${aws_instance.metasploitable2.public_ip} (anonymous or msfadmin)
+     - Web: http://${aws_instance.metasploitable2.public_ip}/
+     - DVWA: http://${aws_instance.metasploitable2.public_ip}/dvwa/
+     - Mutillidae: http://${aws_instance.metasploitable2.public_ip}/mutillidae/
+     
+     ${var.ttl_hours}時間後に自動的に削除されます。
+   EOT
+ } 
```

---

モジュールのパスを修正し、エラーを解決します：

---

```diff
  
    vpc_name = "${local.name_prefix}-vpc"
-   vpc_cidr = "10.50.0.0/16"
-   public_subnet_cidrs = ["10.50.1.0/24"]
  }
  
```

---

モジュール構造を再考して、ファイルを分けて整理します：

---

```diff
- 
+ # このファイルは空です。各機能は個別のファイルに分割されています。
+ # - ttl_destroyer.tf: TTL自動破棄ロジック
+ # - security_group.tf: セキュリティグループ
+ # - vpc.tf: VPC関連リソース 
```

---

次に、上位レベルのTerraformファイルを作成して、各シナリオをどのように実行するかを定義します：

---

```diff
- 
+ # シナリオ選択に基づいて条件付きでモジュールを実行
+ 
+ # Metasploitable2シナリオ
+ module "metasploitable2" {
+   source = "./modules/metasploitable2"
+   
+   # scenario_nameがmetasploitable2またはallの場合にのみ実行
+   count = var.scenario_name == "metasploitable2" || var.scenario_name == "all" ? 1 : 0
+   
+   project_name = var.project_name
+   my_ip_cidr   = var.my_ip_cidr
+   ttl_hours    = var.ttl_hours
+ }
+ 
+ /* この後、以下のモジュールを順次実装
+ module "juice_shop" {
+   source = "./modules/juice_shop"
+   count  = var.scenario_name == "juice_shop" || var.scenario_name == "all" ? 1 : 0
+   ...
+ }
+ 
+ module "terra_goat" {
+   source = "./modules/terra_goat"
+   count  = var.scenario_name == "terra_goat" || var.scenario_name == "all" ? 1 : 0
+   ...
+ }
+ 
+ module "iam_vulnerable" {
+   source = "./modules/iam_vulnerable"
+   count  = var.scenario_name == "iam_vulnerable" || var.scenario_name == "all" ? 1 : 0
+   ...
+ }
+ 
+ module "cloudgoat_min" {
+   source = "./modules/cloudgoat_min"
+   count  = var.scenario_name == "cloudgoat_min" || var.scenario_name == "all" ? 1 : 0
+   ...
+ }
+ 
+ module "awsgoat_min" {
+   source = "./modules/awsgoat_min"
+   count  = var.scenario_name == "awsgoat_min" || var.scenario_name == "all" ? 1 : 0
+   ...
+ }
+ */ 
```

---

また、outputs.tf ファイルを作成して、出力を定義します：

---

```diff
- 
+ # シナリオの出力（条件付き）
+ 
+ # Metasploitable2の出力
+ output "metasploitable2_public_ip" {
+   description = "Metasploitable2のパブリックIP"
+   value       = var.scenario_name == "metasploitable2" || var.scenario_name == "all" ? try(module.metasploitable2[0].metasploitable2_public_ip, "未デプロイ") : "未選択"
+ }
+ 
+ output "metasploitable2_instructions" {
+   description = "Metasploitable2の接続手順"
+   value       = var.scenario_name == "metasploitable2" || var.scenario_name == "all" ? try(module.metasploitable2[0].connection_instructions, "未デプロイ") : "未選択"
+ }
+ 
+ # 他のシナリオ出力は今後追加
+ 
+ # TTL自動破棄の時刻
+ output "auto_destroy_time" {
+   description = "リソースの自動破棄予定時刻"
+   value       = formatdate("YYYY-MM-DD HH:mm:ss", timeadd(timestamp(), "${var.ttl_hours}h"))
+ } 
```

---

最後に、モジュール構造を更新するために、Metasploitable2モジュールを修正します：

---



---

```diff
    name_prefix = "${var.project_name}-metasploitable2"
  }
+ 
+ # 可用性ゾーンの取得
+ data "aws_availability_zones" "available" {
+   state = "available"
+ }
  
  # VPCの作成
- module "vpc" {
-   source = "../common"
- 
-   vpc_name = "${local.name_prefix}-vpc"
+ resource "aws_vpc" "this" {
+   cidr_block           = "10.50.0.0/16"
+   enable_dns_hostnames = true
+ 
+   tags = {
+     Name    = "${local.name_prefix}-vpc"
+     TTL     = "${var.ttl_hours}h"
+     Scenario = "metasploitable2"
+   }
+ }
+ 
+ # Internet Gateway
+ resource "aws_internet_gateway" "this" {
+   vpc_id = aws_vpc.this.id
+ 
+   tags = {
+     Name    = "${local.name_prefix}-igw"
+     TTL     = "${var.ttl_hours}h"
+     Scenario = "metasploitable2"
+   }
+ }
+ 
+ # パブリックサブネット
+ resource "aws_subnet" "public" {
+   vpc_id                  = aws_vpc.this.id
+   cidr_block              = "10.50.1.0/24"
+   availability_zone       = data.aws_availability_zones.available.names[0]
+   map_public_ip_on_launch = true
+ 
+   tags = {
+     Name    = "${local.name_prefix}-public-subnet"
+     TTL     = "${var.ttl_hours}h"
+     Scenario = "metasploitable2"
+   }
+ }
+ 
+ # パブリックルートテーブル
+ resource "aws_route_table" "public" {
+   vpc_id = aws_vpc.this.id
+ 
+   route {
+     cidr_block = "0.0.0.0/0"
+     gateway_id = aws_internet_gateway.this.id
+   }
+ 
+   tags = {
+     Name    = "${local.name_prefix}-public-rt"
+     TTL     = "${var.ttl_hours}h"
+     Scenario = "metasploitable2"
+   }
+ }
+ 
+ # パブリックサブネットとルートテーブルの関連付け
+ resource "aws_route_table_association" "public" {
+   subnet_id      = aws_subnet.public.id
+   route_table_id = aws_route_table.public.id
  }
  
  # セキュリティグループの作成
- module "security_group" {
-   source = "../common"
- 
-   vpc_id       = module.vpc.vpc_id
-   allowed_cidr = var.my_ip_cidr
-   name_prefix  = local.name_prefix
-   description  = "Metasploitable2用セキュリティグループ"
+ resource "aws_security_group" "this" {
+   name        = "${local.name_prefix}-sg"
+   description = "Metasploitable2用セキュリティグループ"
+   vpc_id      = aws_vpc.this.id
+ 
+   # 許可されたCIDRからの接続のみ許可
+   ingress {
+     from_port   = 22
+     to_port     = 22
+     protocol    = "tcp"
+     cidr_blocks = [var.my_ip_cidr]
+     description = "SSH接続"
+   }
+ 
+   ingress {
+     from_port   = 80
+     to_port     = 80
+     protocol    = "tcp"
+     cidr_blocks = [var.my_ip_cidr]
+     description = "HTTP接続"
    }
  
- # 脆弱なサービスのために追加のポートを開放
- resource "aws_security_group_rule" "metasploitable_additional_ports" {
+   # 脆弱なサービスのために追加のポート
+   dynamic "ingress" {
      for_each = {
        ftp       = 21
```

```diff
      }
  
-   security_group_id = module.security_group.security_group_id
-   type              = "ingress"
-   from_port         = each.value
-   to_port           = each.value
-   protocol          = "tcp"
-   cidr_blocks       = [var.my_ip_cidr]
-   description       = "Metasploitable2 - ${each.key}"
+     content {
+       from_port   = ingress.value
+       to_port     = ingress.value
+       protocol    = "tcp"
+       cidr_blocks = [var.my_ip_cidr]
+       description = "Metasploitable2 - ${ingress.key}"
+     }
+   }
+ 
+   # 全ての外向き通信を許可
+   egress {
+     from_port   = 0
+     to_port     = 0
+     protocol    = "-1"
+     cidr_blocks = ["0.0.0.0/0"]
+     description = "全ての外向き通信"
+   }
+ 
+   tags = {
+     Name    = "${local.name_prefix}-sg"
+     TTL     = "${var.ttl_hours}h"
+     Scenario = "metasploitable2"
+   }
  }
  
```

```diff
    instance_type = "t3.micro" # ARM対応のMetasploitableがないためt3.microを使用
  
-   vpc_security_group_ids = [module.security_group.security_group_id]
+   vpc_security_group_ids = [aws_security_group.this.id]
  
    # スポットインスタンスを使用
```

```diff
    }
  
-   subnet_id = module.vpc.public_subnet_ids[0]
+   subnet_id = aws_subnet.public.id
  
    tags = {
```

```diff
  }
  
- # TTL自動破棄
- module "ttl_destroyer" {
-   source = "../common"
- 
-   ttl_hours     = var.ttl_hours
-   enabled       = true
-   scenario_name = "metasploitable2"
+ # TTL自動破棄のためのnull_resource
+ resource "null_resource" "ttl_destroyer" {
+   # TTL時間が変更されたら再実行
+   triggers = {
+     ttl_hours = var.ttl_hours
+   }
+ 
+   # terraform destroyをバックグラウンドで予約実行
+   provisioner "local-exec" {
+     command = <<-EOT
+       (
+         # バックグラウンドで実行
+         echo "TTL: ${var.ttl_hours}時間後（$(date -d "+${var.ttl_hours} hour" "+%Y-%m-%d %H:%M:%S")）に'metasploitable2'シナリオを自動破棄します"
+         sleep ${var.ttl_hours * 3600}
+         cd ${path.root}
+         echo "TTL期限切れ: 'metasploitable2'シナリオを自動破棄します（$(date "+%Y-%m-%d %H:%M:%S")）"
+         terraform destroy -auto-approve -var="scenario_name=metasploitable2"
+       ) &>/tmp/ttl_destroyer_metasploitable2.log &
+     EOT
+   }
  }
  
```

---

最後に、チェックリストを確認するため、.gitignoreファイルも追加しておきましょう：

---

```diff
  # SpecStory explanation file
  .specstory/.what-is-this.md
+ 
+ # Local .terraform directories
+ **/.terraform/*
+ 
+ # .tfstate files
+ *.tfstate
+ *.tfstate.*
+ 
+ # Crash log files
+ crash.log
+ crash.*.log
+ 
+ # Exclude all .tfvars files, which might contain sensitive data
+ *.tfvars
+ *.tfvars.json
+ 
+ # ただし、examples以下のファイルは含める
+ !examples/*.tfvars.example
+ 
+ # Ignore override files
+ override.tf
+ override.tf.json
+ *_override.tf
+ *_override.tf.json
+ 
+ # Ignore CLI configuration files
+ .terraformrc
+ terraform.rc
+ 
+ # .terraform.lock.hcl files (Terraform 0.14 以降)
+ .terraform.lock.hcl
+ 
+ # 自動破棄ログファイル
+ ttl_destroyer_*.log
+ 
+ # IDEファイル
+ .idea/
+ .vscode/
+ *.swp
+ *.swo
+ 
+ # OS固有のファイル
+ .DS_Store
+ Thumbs.db
  
```

---

最初のタスクである「リポジトリ初期化&基本構成」が完了しました！以下を実装しました：

1. プロジェクト初期化 (ディレクトリ構造、Gitリポジトリ)
2. Terraformの基本設定ファイル (main.tf, variables.tf)
3. 共通モジュール (ttl_destroyer, security_group, vpc)
4. 最優先のMetasploitable2モジュール
5. 環境管理用スクリプト (run.sh)
6. シナリオ選択ロジック (scenarios.tf, outputs.tf)
7. Gitignore設定

次のステップでは、他のシナリオモジュール（Juice Shop, TerraGoat等）を実装できます。設計方針として、各シナリオを完全に独立したモジュールとし、デプロイと破棄がシンプルになるようにしました。TTL自動破棄ロジックはMetasploitable2モジュール内に直接組み込み、依存関係を減らしてコスト効率を高めています。

---

_**User**_

いったん現在の状態をリモートリポジトリにプッシュしよう。まずはコミットメッセージを作成

---

_**Assistant**_



---

コミットメッセージの作成とプッシュを行いましょう：

---



---



---

